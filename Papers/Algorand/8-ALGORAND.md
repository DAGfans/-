8

ALGORAND

Building Algorand on top of the primitives we have described so far requires Algorand to address a number of higher-level issues, which this section discusses.

8.1 Block format

Algorand’s blocks consist of a list of transactions, along with metadata needed by BA⋆. Specifically, the metadata consists of the round number, the proposer’s VRF-based seed (§6), a hash of the previous block in the ledger, and a timestamp indicating when the block was proposed. The list of transactions in a block logically translates to a set of weights for each user’s public key (based on the balance of currency for that key), along with the total weight of all outstanding currency.

Once a user receives a block from the highest-priority pro- poser, the user validates the block contents before passing it on to BA⋆. In particular, the user checks that all transactions are valid; that the seed is valid; that the previous block hash is correct; that the block round number is correct; and that the timestamp is greater than that of the previous block and also approximately current (say, within an hour). If any of them are incorrect, the user passes an empty block to BA⋆.

8.2 Safety and liveness

To a large extent, Algorand relies on BA⋆ to reach consensus on blocks in the ledger. Algorand confirms transactions only when they appear in a final block, or in the predecessor of a final block. Final blocks guarantee that no other block could have reached consensus in the same round. This means that all final blocks are totally ordered with respect to one another, since (1) blocks form a linear chain, and (2) there can be exactly one final block at any given position in the chain. In other words, given two final blocks, one of them (the one with the smaller round number r 1 ) must be a predecessor of the other (the one with the higher round number r 2 ), since there must be some predecessor of the r 2 block in round r 1 , and the safety condition guarantees that the r 1 block is the only possible such block.

The remaining issue is that, if the network is not strongly synchronous, BA⋆may create forks (i.e., different users reach consensus on different blocks). This does not violate safety, because BA⋆ will return tentative consensus in this situation. However, forks do impact liveness: users on different forks will have different ctx.last_block values, which means they will not count each others’ votes. As a result, at least one of the forks (and possibly all of the forks) will not have enough participants to cross the vote threshold, and BA⋆ will not be able to reach consensus on any more blocks on that fork.

To resolve these forks, Algorand periodically proposes a fork that all users should agree on, and uses BA⋆ to reach consensus on whether all users should, indeed, switch to this fork. To determine the set of possible forks, Algorand users passively monitor all BA⋆ votes (i.e., even votes whose prev_hash value does not match the current user’s chain), and keep track of all forks. Users then use loosely synchro- nized clocks to stop regular block processing and kick off the recovery protocol at every time interval (e.g., every hour), which will propose one of these forks as the fork that every- one should agree on.

The recovery protocol starts by having users propose a fork using the block proposal mechanism (§6). Specifically, if a user is chosen to be a “fork proposer,” that user proposes an empty block whose predecessor hash is the longest fork (by the number of blocks) observed by the user so far. Each user waits for the highest-priority fork proposal, much as in the block proposal mechanism. Each user validates the proposed block, by ensuring that the block’s parent pointer is a chain that is as long as the longest chain seen by that user. Choosing the longest fork ensures that this fork will include all final blocks. Finally, the user invokes BA⋆ to reach consensus on this block, passing the round number found in the proposed block.

In order for BA⋆ to reach consensus on one of the forks, all Algorand users must use the same seed and user weights. This means that Algorand must use user weights and seeds from before any possible forks occurred. To do this, Algorand relies on the weak synchrony assumption—namely, that in every period of length b (think of b as 1 day), there must be a strongly synchronous period of length s < b (think of s as a few hours). Under this assumption, using the block timestamps, Algorand quantizes time into b-long periods (think days), and finds the most recent block from the next- to-last complete b-long period. Algorand then uses the seed from this block, and uses user weights from the last block that was agreed upon at least b-long time before it (§5.3).

Algorand takes the seed from the block from the next- to-last b-long period because the most recent b-long period may still have an unresolved fork. Such a fork would prevent users from agreeing on the seed and weights used in the recovery. However, as long as Algorand can recover within the s-long strongly synchronous period in the most recent b-long period, all users will agree on the same block from the next-to-last period (as long as their clocks are roughly synchronized).

To ensure that Algorand recovers from a fork (i.e., most honest users switch to the same fork) within the s-long syn- chronous period, Algorand users repeatedly attempt to reach consensus on a fork (applying a hash function to the seed each time to produce a different set of proposers and com- mittee members), until they achieve consensus. Since, by assumption, Algorand is operating in a strongly synchronous period, it is not important whether BA⋆ returns “final” or “tentative” consensus in this case. When Algorand is recov- ering outside of a strongly synchronous period, we cannot ensure recovery within s time.

8.3 Bootstrapping

Bootstrapping the system. To deploy Algorand, a com- mon genesis block must be provided to all users, along with the initial cryptographic sortition seed. The value of seed 0 specified in the genesis block is decided using distributed random number generation [14], after the public keys and weights for the initial set of participants are publicly known.

Bootstrapping new users. Users that join the system need to learn the current state of the system, which is defined to be the result of a chain of BA⋆ consensus outcomes. To help users catch up, Algorand generates a certificate for ev- ery block that was agreed upon by BA⋆ (including empty blocks). The certificate is an aggregate of the votes from the last step of BinaryBA⋆() (not including the final step) that would be sufficient to allow any user to reach the same con- clusion by processing these votes (i.e., there must be at least ⌊T step ·τ step ⌋ +1 votes). Importantly, the users must check the sortition hashes and proofs just like in Algorithm 6, and that all messages in the certificate are for the same Algorand round and BA⋆ step.

Certificates allow new users to validate prior blocks. Users validate blocks in order, starting from the genesis block. This ensures that the user knows the correct weights for verifying sortition proofs in any given round. Users can also request a certificate proving the safety of a block; this is simply the collection of votes for the final step. Since final blocks are totally ordered, users need to check the safety of only the most recent block.

One potential risk created by the use of certificates is that an adversary can provide a certificate that appears to show that BA⋆ completed after some large number of steps. This gives the adversary a chance to find a BA⋆ step number (up to MaxSteps) in which the adversary controls more than a threshold of the selected committee members (and to then create a signed certificate using their private keys). We set the committee size to be sufficiently large to ensure the attacker has negligible probability of finding such a step number. For τ step > 1,000, the probability of this attack is less than 2 −166 at every step, making this attack infeasible.

Storage. The block history and matching certificates allow new users to catch-up, and are not required for users who are already up-to-date with the current ledger. Therefore Al- gorand distributes certificate and block storage across users. For N shards, users store blocks/certificates whose round number equals their public key modulo N.

8.4 Communication

Gossiping blocks and relaying messages. Algorand’s block proposal protocol (§6) assumed that chosen users can gossip new blocks before an adversary can learn the user’s identity and mount a targeted DoS attack against them. In practice, Algorand’s blocks are larger than the maximum packet size, so it is inevitable that some packets from a cho- sen block proposer will be sent before others. A particularly fast adversary could take advantage of this to immediately DoS any user that starts sending multiple packets, on the presumption that the user is a block proposer.

Formally, this means that Algorand’s liveness guarantees are slightly different in practice: instead of providing liveness in the face of immediate targeted DoS attacks, Algorand ensures liveness as long as an adversary cannot mount a targeted DoS attack within the time it takes for the victim to send a block over a TCP connection (a few seconds). We believe this does not matter significantly; an adversary with such a quick reaction time likely also has broad control over the network, and thus can prevent Algorand nodes from communicating at all. Another approach may be to rely on Tor [19] to make it difficult for an adversary to quickly disconnect a user.

To avoid an adversary from sending garbage messages and overwhelming Algorand’s gossip network, Algorand nodes must validate messages before relaying them. Specifically, Algorand nodes should validate each message using Algo- rithm 6, and avoid relaying more than one message signed by a given public key per ⟨round, step⟩.

Scalability. The communication costs for each user depend on the expected size of the committee and the number of block proposers, which Algorand sets throughτ proposer , τ step , and τ final (independent of the number of users). As more users join, it takes a message longer to disseminate in the gossip network. Algorand’s gossip network forms a random network graph (each user connects to random peers). Our theoretical analysis suggests that almost all users will be part of one connected component in the graph, and that dis- semination time grows with the diameter of that component, which is logarithmic in the number of users [44]. Experi- ments confirm that Algorand’s performance is only slightly affected by more users (§10).

Since our random graph uses a fixed number of peers, one potential concern is that it may contain disconnected components [22]. However, only a small fraction of users might end up in a disconnected component, which does not pose a problem for BA⋆. Moreover, Algorand replaces gossip peers each round, which helps users recover from being possibly disconnected in a previous round.
Figure 4: Implementation parameters.
