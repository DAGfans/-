## 6 BLOCK PROPOSAL

## 6 区块提议

To ensure that some block is proposed in each round, Algorand sets the sortition threshold for the block-proposal role, τ proposer , to be greater than 1 (although Algorand will reach consensus on at most one of these proposed blocks). Appendix B proves that choosing τ proposer = 26 ensures that a reasonable number of proposers (at least one, and no more than 70, as a plausible upper bound) are chosen with very high probability (e.g., 1−10 −11 ).

为了确保每轮都有一些区块被提出，Algorand设置了作为区块提议者的抽签阈值τ\_PROPOSER，要大于1，(尽管Algorand会在最多一个被提议的区块中达到共识)。附录B证明了选择τ\_PROPOSER=26的时候(最少，最多是70上界)可以确保能够被高概率的选出(例如 1-10^-11)

**Minimizing unnecessary block transmissions.** One risk of choosing several proposers is that each will gossip their own proposed block. For a large block (say, 1 MByte), this can incur a significant communication cost. To reduce this cost, the sortition hash is used to prioritize block proposals: For each selected sub-user 1,...,j of user i, the priority for the block proposal is obtained by hashing the (verifiably random) hash output of VRF concatenated with the sub-user index. The highest priority of all the block proposer’s selected sub-users is the priority of the block.

**减少不必要的块传输。** 选择几个提议者的风险是每个人都会gossip他们自己的提议块。 对于大块（比如1兆字节），这可能会产生显着的通信成本。 为了降低这种成本，抽签hash被用来优化区块提议：对于每个用户i被选定的的子用户1...j，块提议的优先级是通过哈希VRF的output hash的输出再链接上子用户index。 所有块提议者的被选择的子用户的最高优先级是这个块的优先级。

Algorand users discard messages about blocks that do not have the highest priority seen by that user so far. Algorand also gossips two kinds of messages: one contains just the priorities and proofs of the chosen block proposers (from sortition), and the other contains the entire block, which also includes the proposer’s sortition hash, and proof. The first kind of message is small (about 200 Bytes), and propagates quickly through the gossip network. These messages enable most users to learn who is the highest priority proposer, and thus quickly discard other proposed blocks.

Algorand用户抛弃有关该用户迄今为止看到的不是最高优先级的块的消息。 Algorand还gossip两种消息：一种仅包含所选块提议者的优先级和证明（来自抽签），另一块包含整个块，其中还包括提议者的分类哈希和证明。 第一种消息很小（约200字节），并通过gossip网络迅速传播。 这些消息使大多数用户能够了解谁是最高优先级的提议者，并因此迅速放弃其他提议的块。

**Waiting for block proposals.** Each user must wait a cer- tain amount of time to receive block proposals via the gossip protocol. Choosing this time interval does not impact Algo- rand’s safety guarantees but is important for performance. Waiting a short amount of time will mean no received pro- posals. If the user receives no block proposals, he or she initializes BA⋆ with the empty block, and if many users do so, Algorand will reach consensus on an empty block. On the other hand, waiting too long will receive all block proposals but also unnecessarily increase the confirmation latency.

**等待区块提议。**每个用户都必须等待一定的时间才能通过gossip协议接收块提议。 选择此时间间隔不会影响Algorand的安全保证，但对性能很重要。 等待很短的时间将意味着没有收到建议。 如果用户没有收到任何块提议，他或她会用空白块初始化BA⋆，如果有许多用户这样做，Algorand会在空块上达成一致。另一方面要是等太久又会造成没必要的延时。

To determine the appropriate amount of time to wait for block proposals, we consider the plausible scenarios that a user might find themselves in. When a user starts waiting for block proposals for roundr, they may be one of the first users to reach consensus in round r −1. Since that user completed round r −1, sufficiently many users sent a message for the last step of BA⋆ in that round, and therefore, most of the network is at most one step behind this user. Thus, the user must somehow wait for others to finish the last step of BA⋆ from round r − 1. At this point, some proposer in round r that happens to have the highest priority will gossip their priority and proof message, and the user must somehow wait to receive that message. Then, the user can simply wait until they receive the block corresponding to the highest priority proof (with a timeout λ block , on the order of a minute, after which the user will fall back to the empty block).

为了确定等待分组建议的适当时间，我们考虑一个可能的场景。当一个用户开始等待第r轮的区块提议时，他们可能是在第r-1中第一批达到共识的人之一。 由于该用户完成了第r -1轮，所以足够多的用户在该轮中发送了BA⋆的最后一步的消息，因此，大多数网络中的其他用户最多落后于该用户一步。 因此，该用户必须等待其他人从第r-1轮完成BA⋆的最后一步。 此时，一些r轮中的提议者恰好具有最高优先级将gossip他们的优先级和证明，并且用户必须以某种方式等待接收该消息。 然后，用户可以简单地等待，直到他们收到对应于最高优先级证明的块（具有一个超时λ\_BLOCK，大约一分钟，之后用户将回退到空块）。

It is impossible for a user to wait exactly the correct amount for the first two steps of the above scenario. Thus, Algorand estimates these quantities (λ stepvar , the variance in how long it takes different users to finish the last step of BA⋆, and λ priority , the time taken to gossip the priority and proof message), and waits for λ stepvar +λ priority time to identify the highest priority. §10 experimentally shows that these parameters are, conservatively, 5 seconds each. As mentioned above, Algorand would remain safe even if these estimates were inaccurate.

在上面的场景的前两个步骤中，用户不可能完全等待正确的数量。 因此，Algorand估计了这些数量（λ\_stepvar，不同用户完成BA⋆最后一步需要多长时间的差异，以及λ\_priority，gossip的优先级和证明的时间），并等待λ\_stepvar+λ\_priority时间到确定最高优先级。 §10通过实验表明，这些参数是保守的，每个参数5秒。 如上所述，即使这些估计值不准确，Algorand也会保持安全。

**Malicious proposers.** Even if some block proposers are malicious, the worst-case scenario is that they trick different Algorand users into initializing BA⋆ with different blocks. This could in turn cause Algorand to reach consensus on an empty block, and possibly take additional steps in doing so. However, it turns out that even this scenario is relatively unlikely. In particular, if the adversary is not the highest pri- ority proposer in a round, then the highest priority proposer will gossip a consistent version of their block to all users. If the adversary is the highest priority proposer in a round, they can propose the empty block, and thus prevent any real transactions from being confirmed. However, this happens with probability of at most 1−h, by Algorand’s assumption that at least h > 2/3 of the weighted user are honest.

**恶意的提议者。**即使某些块提议者是恶意的，最坏的情况是他们欺骗不同的Algorand用户使用不同的块来初始化BA⋆。 这可能会导致Algorand在空块达成共识，并可能采取额外措施。 然而，事实证明，即使这种情况相对不太可能。 特别是，如果攻击者不是一轮中最高优先级的提案者，那么最高优先级提案者会向其所有用户传送一致的版本。 如果攻击者是一轮中最高优先级的提议者，他们可以提出空白块，从而防止任何实际交易被确认。 然而，这种情况发生在 概率最多为1-h下，通过Algorand的假设至少h> 2/3的权益用户是诚实的。